<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leonida - Stipple Head</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            min-height: 100vh;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            color: #fff;
        }
        #container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
        
        .status {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8em;
            color: rgba(100, 150, 255, 0.5);
            letter-spacing: 0.1em;
            z-index: 10;
        }
        
        .controls {
            position: fixed;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10;
            background: rgba(0,0,0,0.85);
            padding: 12px;
            border-radius: 8px;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
            width: 240px;
            font-size: 0.7em;
        }
        .controls h3 {
            font-size: 0.85em;
            text-transform: uppercase;
            color: rgba(255,255,255,0.4);
            margin-top: 8px;
            border-top: 1px solid rgba(255,255,255,0.1);
            padding-top: 8px;
        }
        .controls h3:first-child {
            margin-top: 0;
            border-top: none;
            padding-top: 0;
        }
        .slider-row {
            display: flex;
            flex-direction: column;
            gap: 3px;
            margin-bottom: 6px;
        }
        .slider-row label {
            color: rgba(255,255,255,0.7);
        }
        .slider-row input[type="range"] {
            width: 100%;
        }
        .range-inputs {
            display: flex;
            gap: 4px;
            align-items: center;
        }
        .range-inputs input[type="number"] {
            width: 50px;
            padding: 2px 4px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 3px;
            color: #fff;
            font-size: 0.9em;
        }
        .range-inputs span {
            color: rgba(255,255,255,0.4);
            font-size: 0.9em;
        }
        .controls select {
            padding: 4px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(0,0,0,0.5);
            color: #fff;
            width: 100%;
        }
        .controls input[type="color"] {
            width: 100%;
            height: 25px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div class="status" id="status">Loading model...</div>
    
    <div class="controls">
        <h3>Particles</h3>
        
        <div class="slider-row">
            <label>Size</label>
            <input type="range" id="size" min="0.05" max="3" value="0.4" step="0.01">
            <div class="range-inputs">
                <input type="number" id="sizeMin" value="0.05" step="0.01"> 
                <span>-</span>
                <input type="number" id="sizeMax" value="3" step="0.1">
            </div>
        </div>
        
        <div class="slider-row">
            <label>Density</label>
            <input type="range" id="density" min="1" max="100" value="35">
            <div class="range-inputs">
                <input type="number" id="densityMin" value="1"> 
                <span>-</span>
                <input type="number" id="densityMax" value="100">
            </div>
        </div>
        
        <div class="slider-row">
            <label>Shape</label>
            <select id="shape">
                <option value="circle">Circle</option>
                <option value="square">Square</option>
                <option value="soft" selected>Soft Circle</option>
            </select>
        </div>
        
        <h3>Dissipation</h3>
        
        <div class="slider-row">
            <label>Reference Point</label>
            <select id="reference">
                <option value="model">Model (face = front)</option>
                <option value="camera">Camera (facing = front)</option>
            </select>
        </div>
        
        <div class="slider-row">
            <label>Effect Start (% from front unaffected)</label>
            <input type="range" id="effectStart" min="0" max="90" value="30">
            <div class="range-inputs">
                <input type="number" id="effectStartMin" value="0"> 
                <span>-</span>
                <input type="number" id="effectStartMax" value="90">
            </div>
        </div>
        
        <div class="slider-row">
            <label>Density Falloff</label>
            <input type="range" id="dissipation" min="0" max="100" value="50">
            <div class="range-inputs">
                <input type="number" id="dissipationMin" value="0"> 
                <span>-</span>
                <input type="number" id="dissipationMax" value="100">
            </div>
        </div>
        
        <div class="slider-row">
            <label>Float Away Distance</label>
            <input type="range" id="floatAway" min="0" max="200" value="60">
            <div class="range-inputs">
                <input type="number" id="floatAwayMin" value="0"> 
                <span>-</span>
                <input type="number" id="floatAwayMax" value="200">
            </div>
        </div>
        
        <h3>Appearance</h3>
        
        <div class="slider-row">
            <label>Color</label>
            <input type="color" id="color" value="#4488ff">
        </div>
        
        <div class="slider-row">
            <label>Glow</label>
            <input type="range" id="glow" min="0" max="200" value="30">
            <div class="range-inputs">
                <input type="number" id="glowMin" value="0"> 
                <span>-</span>
                <input type="number" id="glowMax" value="200">
            </div>
        </div>
        
        <div class="slider-row">
            <label>Background</label>
            <select id="background">
                <option value="dark">Dark</option>
                <option value="light">Light</option>
            </select>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        
        // Scene
        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 3);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);
        
        // Post-processing
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.3, 0.4, 0.85
        );
        composer.addPass(bloomPass);
        
        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // State
        let time = 0;
        let pointsMesh = null;
        let allVertices = [];
        let particleBaseData = []; // Original positions + random seeds
        
        // Settings
        let settings = {
            size: 0.4,
            density: 0.35,
            shape: 'soft',
            reference: 'model',
            effectStart: 0.3,  // 30% from front unaffected
            dissipation: 0.5,
            floatAway: 0.6,
            color: new THREE.Color(0x4488ff),
            glow: 0.3,
            isDark: true
        };
        
        // Load model
        const loader = new OBJLoader();
        loader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/models/obj/walt/WaltHead.obj', (obj) => {
            document.getElementById('status').textContent = 'Processing...';
            
            let vertices = [];
            obj.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    const positions = child.geometry.attributes.position;
                    for (let i = 0; i < positions.count; i++) {
                        vertices.push({
                            x: positions.getX(i),
                            y: positions.getY(i),
                            z: positions.getZ(i)
                        });
                    }
                }
            });
            
            // Normalize
            const bounds = { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity, minZ: Infinity, maxZ: -Infinity };
            vertices.forEach(v => {
                bounds.minX = Math.min(bounds.minX, v.x); bounds.maxX = Math.max(bounds.maxX, v.x);
                bounds.minY = Math.min(bounds.minY, v.y); bounds.maxY = Math.max(bounds.maxY, v.y);
                bounds.minZ = Math.min(bounds.minZ, v.z); bounds.maxZ = Math.max(bounds.maxZ, v.z);
            });
            
            const cx = (bounds.minX + bounds.maxX) / 2;
            const cy = (bounds.minY + bounds.maxY) / 2;
            const cz = (bounds.minZ + bounds.maxZ) / 2;
            const scale = 2 / Math.max(bounds.maxX - bounds.minX, bounds.maxY - bounds.minY, bounds.maxZ - bounds.minZ);
            
            allVertices = vertices.map(v => ({
                x: (v.x - cx) * scale,
                y: (v.y - cy) * scale,
                z: (v.z - cz) * scale
            }));
            
            initParticles();
        });
        
        function initParticles() {
            // Sample all vertices once, store with random seeds
            particleBaseData = allVertices
                .filter(() => Math.random() < settings.density)
                .map(v => ({
                    x: v.x, y: v.y, z: v.z,
                    // Random seeds for consistent animation
                    seed1: Math.random() * Math.PI * 2,
                    seed2: Math.random() * Math.PI * 2,
                    driftX: (Math.random() - 0.5) * 2,
                    driftY: (Math.random() - 0.3),
                    driftZ: -Math.random(),  // Drift backward
                    speed: 0.3 + Math.random() * 0.4,
                    sizeVar: 0.7 + Math.random() * 0.6
                }));
            
            createMesh();
        }
        
        function createMesh() {
            if (pointsMesh) scene.remove(pointsMesh);
            
            const count = particleBaseData.length;
            const positions = new Float32Array(count * 3);
            const basePositions = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const seeds = new Float32Array(count * 4); // seed1, seed2, speed, sizeVar
            const drifts = new Float32Array(count * 3);
            
            for (let i = 0; i < count; i++) {
                const p = particleBaseData[i];
                basePositions[i * 3] = p.x;
                basePositions[i * 3 + 1] = p.y;
                basePositions[i * 3 + 2] = p.z;
                positions[i * 3] = p.x;
                positions[i * 3 + 1] = p.y;
                positions[i * 3 + 2] = p.z;
                sizes[i] = settings.size * p.sizeVar;
                seeds[i * 4] = p.seed1;
                seeds[i * 4 + 1] = p.seed2;
                seeds[i * 4 + 2] = p.speed;
                seeds[i * 4 + 3] = p.sizeVar;
                drifts[i * 3] = p.driftX;
                drifts[i * 3 + 1] = p.driftY;
                drifts[i * 3 + 2] = p.driftZ;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('basePosition', new THREE.BufferAttribute(basePositions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('seeds', new THREE.BufferAttribute(seeds, 4));
            geometry.setAttribute('drift', new THREE.BufferAttribute(drifts, 3));
            
            const shapeVal = settings.shape === 'circle' ? 0 : (settings.shape === 'square' ? 1 : 2);
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: settings.color },
                    shape: { value: shapeVal },
                    time: { value: 0 },
                    effectStart: { value: settings.effectStart },
                    dissipation: { value: settings.dissipation },
                    floatAway: { value: settings.floatAway },
                    reference: { value: settings.reference === 'camera' ? 1 : 0 },
                    cameraPos: { value: camera.position.clone() },
                    cameraDir: { value: new THREE.Vector3(0, 0, -1) }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 basePosition;
                    attribute vec4 seeds;
                    attribute vec3 drift;
                    
                    uniform float time;
                    uniform float effectStart;
                    uniform float dissipation;
                    uniform float floatAway;
                    uniform int reference;
                    uniform vec3 cameraPos;
                    uniform vec3 cameraDir;
                    
                    varying float vAlpha;
                    varying float vDepth;
                    
                    void main() {
                        vec3 pos = basePosition;
                        float depth;
                        
                        if (reference == 1) {
                            // Camera reference: depth based on dot with camera direction
                            vec3 toPoint = normalize(basePosition);
                            depth = -dot(toPoint, cameraDir); // -1 to 1
                            depth = (depth + 1.0) / 2.0; // 0 = back, 1 = front
                        } else {
                            // Model reference: depth based on z
                            depth = (basePosition.z + 1.0) / 2.0; // 0 = back, 1 = front
                        }
                        
                        // Effect starts after effectStart threshold
                        // depth > effectStart = unaffected (front)
                        // depth < effectStart = affected (back)
                        float effectZone = 1.0 - effectStart;
                        float normalizedBack = max(0.0, (effectStart - depth) / effectStart);
                        
                        // Float away: increases with normalizedBack
                        float floatAmount = normalizedBack * normalizedBack * floatAway;
                        float anim = sin(time * seeds.z + seeds.x) * 0.5 + 0.5;
                        
                        pos += drift * floatAmount * (0.5 + anim * 0.5);
                        pos.y += sin(time * 0.5 + seeds.y) * 0.02 * normalizedBack;
                        
                        // Alpha: fades with normalizedBack and dissipation
                        vAlpha = 1.0 - normalizedBack * dissipation;
                        vAlpha = clamp(vAlpha, 0.05, 1.0);
                        
                        vDepth = depth;
                        
                        // Size: smaller toward back
                        float sizeScale = 1.0 - normalizedBack * 0.5;
                        
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = size * sizeScale * (80.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform int shape;
                    varying float vAlpha;
                    varying float vDepth;
                    
                    void main() {
                        vec2 center = gl_PointCoord - 0.5;
                        float dist = length(center);
                        float a = vAlpha;
                        
                        if (shape == 0) {
                            if (dist > 0.5) discard;
                        } else if (shape == 1) {
                            // square
                        } else {
                            if (dist > 0.5) discard;
                            a *= smoothstep(0.5, 0.1, dist);
                        }
                        
                        gl_FragColor = vec4(color, a);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            
            pointsMesh = new THREE.Points(geometry, material);
            scene.add(pointsMesh);
            
            document.getElementById('status').textContent = `${count.toLocaleString()} particles`;
        }
        
        // Animation
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;
            
            if (pointsMesh) {
                const uniforms = pointsMesh.material.uniforms;
                uniforms.time.value = time;
                uniforms.cameraPos.value.copy(camera.position);
                
                // Camera direction
                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                uniforms.cameraDir.value.copy(dir);
            }
            
            bloomPass.strength = settings.glow;
            controls.update();
            composer.render();
        }
        animate();
        
        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // === Control Helpers ===
        function setupSlider(id, settingKey, isPercent = true, rebuild = false) {
            const slider = document.getElementById(id);
            const minInput = document.getElementById(id + 'Min');
            const maxInput = document.getElementById(id + 'Max');
            
            function updateSetting() {
                const val = parseFloat(slider.value);
                settings[settingKey] = isPercent ? val / 100 : val;
                if (rebuild) {
                    initParticles();
                } else if (pointsMesh) {
                    pointsMesh.material.uniforms[settingKey].value = settings[settingKey];
                }
            }
            
            slider.addEventListener('input', updateSetting);
            
            minInput.addEventListener('change', () => {
                slider.min = minInput.value;
            });
            
            maxInput.addEventListener('change', () => {
                slider.max = maxInput.value;
            });
        }
        
        // Setup all sliders
        setupSlider('size', 'size', false, true);
        setupSlider('density', 'density', true, true);
        setupSlider('effectStart', 'effectStart', true, false);
        setupSlider('dissipation', 'dissipation', true, false);
        setupSlider('floatAway', 'floatAway', true, false);
        setupSlider('glow', 'glow', true, false);
        
        document.getElementById('shape').addEventListener('change', (e) => {
            settings.shape = e.target.value;
            createMesh();
        });
        
        document.getElementById('reference').addEventListener('change', (e) => {
            settings.reference = e.target.value;
            if (pointsMesh) {
                pointsMesh.material.uniforms.reference.value = settings.reference === 'camera' ? 1 : 0;
            }
        });
        
        document.getElementById('color').addEventListener('input', (e) => {
            settings.color = new THREE.Color(e.target.value);
            if (pointsMesh) pointsMesh.material.uniforms.color.value = settings.color;
        });
        
        document.getElementById('background').addEventListener('change', (e) => {
            settings.isDark = e.target.value === 'dark';
            scene.background = new THREE.Color(settings.isDark ? 0x1a1a2e : 0xf5f5f5);
        });
    </script>
</body>
</html>
